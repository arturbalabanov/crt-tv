# A script to control the system volume as Kodi has its own volume control
# and there doesn't seem to be a way to use the system volume control instead

import argparse
import subprocess
import re

import xbmc

parser = argparse.ArgumentParser()
parser.add_argument("direction", choices=["up", "down"])

args = parser.parse_args()

NEW_VOLUME_REGEX = re.compile(r"Mono:.*\[(?P<new_volume_perc>\d+)%\]", flags=re.MULTILINE | re.IGNORECASE)

def send_kodi_notification(message: str, *, timeout_ms: int = 100) -> None:
    xbmc.executebuiltin('Notification(System Volume, {}, {})'.format(message, timeout_ms))


def change_volume(direction: str, step_perc: int, *, notification_timeout_ms: int = 100) -> None:
    if direction == "up":
        change_sign = "+"
        change_str = "INCREASED"
    elif direction == "down":
        change_sign = "-"
        change_str = "DECREASED"
    else:
        raise RuntimeError("Invalid direction: {}".format(direction))
        
    result = subprocess.run(
        ["amixer", "set", "Headphone", "-M", "{}%{}".format(step_perc, change_sign)],
        check=False,
        capture_output=True,
    )

    if result.returncode != 0:
        send_kodi_notification("ERROR: Failed to change volume", timeout_ms=2000)
        return
    
    notification_msg = "{} by {}%".format(change_str, step_perc)
    
    output_str = result.stdout.decode("utf-8")
    new_volume_match = NEW_VOLUME_REGEX.search(output_str)
    
    if new_volume_match:
        notification_msg += " to {}%".format(new_volume_match.group("new_volume_perc"))
    
    send_kodi_notification(notification_msg, timeout_ms=notification_timeout_ms)

if args.direction == "up":
    change_volume("up", 10)
elif args.direction == "down":
    change_volume("down", 10)
else:
    raise RuntimeError("Invalid direction: {}".format(args.direction))
